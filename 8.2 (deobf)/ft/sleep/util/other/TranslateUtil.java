package ft.sleep.util.other;

public class TranslateUtil {
   public float thank$;
   public float luggage$;
   public long white$;

   public TranslateUtil(float ividugir, float tadefuce) {
      ifezozay.thank$ = (float)ividugir;
      ifezozay.luggage$ = (float)tadefuce;
      ifezozay.white$ = System.currentTimeMillis();
   }

   public void _watts(float these, float overcome, float magnetic) {
      Object attended = System.currentTimeMillis();
      Object halifax = attended - palmer.white$;
      palmer.white$ = attended;
      int var8 = (int)(Math.abs(these - palmer.thank$) * magnetic);
      int var9 = (int)(Math.abs(overcome - palmer.luggage$) * magnetic);
      palmer.thank$ = palmer._counting((float)these, palmer.thank$, halifax, var8);
      palmer.luggage$ = palmer._counting((float)overcome, palmer.luggage$, halifax, var9);
   }

   public float _heath() {
      return figuzafi.thank$;
   }

   public void _plastic(float vincent) {
      kinds.thank$ = (float)vincent;
   }

   public float _speech() {
      return gepavezu.luggage$;
   }

   public void _noise(float round) {
      wanting.luggage$ = (float)round;
   }

   public float _counting(float judgment, float cleaning, long partner, int tobago) {
      Object mothers = (float)(cleaning - judgment);
      if (partner < ((long)-843860873 ^ -843860874L)) {
         partner = (long)-1988588413 ^ -1988588414L;
      }

      if (mothers > (float)tobago) {
         double var7 = (double)((long)tobago * partner / ((long)-285831504 ^ -285831520L)) < 0.25D ? 0.5D : (double)((long)tobago * partner / ((long)1552167605 ^ 1552167589L));
         cleaning = (float)((double)cleaning - var7);
         if (cleaning < judgment) {
            cleaning = judgment;
         }
      } else if (mothers < (float)(-tobago)) {
         double var10 = (double)((long)tobago * partner / ((long)2091542296 ^ 2091542280L)) < 0.25D ? 0.5D : (double)((long)tobago * partner / ((long)1389606454 ^ 1389606438L));
         cleaning = (float)((double)cleaning + var10);
         if (cleaning > judgment) {
            cleaning = judgment;
         }
      } else {
         cleaning = judgment;
      }

      return (float)cleaning;
   }
}
